#!@bashrun@
# -*- mode: sh; -*-

function usage {
    test -n "$1" && echo "error: $1";
    
    cat <<EOT
usage: make-cpan-dist Options

Utility to create a CPAN distribution. See 'man make-cpan-dist'

Options
-------
-a author      - author (ex: Anonymouse <anonymouse@example.org>)
-A any version - do not include version numbers for required modules
-b buildspec   - use a buildspec file instead of options
-d description - description to be included CPAN
-D file        - use file as the dependency list
-T file        - use file as the test dependency list
-e path        - path for extra .pl files to package
-h             - help
-f file        - file containing a list of extra files to include
-l path        - path to Perl modules
-L log level   - logging level 1=error, 5=trace
-m name        - module name
-o dir         - output directory (default: current directory)
-p             - preserve Makefile.PL
-P file        - file that contains a list of modules to be packaged
-r pgm         - script or program to list dependencies
-s             - use scandeps.pl to find dependncies
-R yes/no      - recurse directories for files to package (default: yes)
-t path        - path to test files
-v             - more verbose output
-x             - do not cleanup files

* NOCLEANUP=1, PRESERVE_MAKEFILE=1 can also be passed as environment
  variables.

* use -L for logging level or DEBUG=1 (debug), DEBUG=2 (trace)

This script is free software. It may be used, redistributed and/or
modified under the same terms as Perl itself.
EOT
    
    exit;
}

function FATAL_ERROR {
    ERROR "$1"
    
    exit "${2:-1}"
}

function ERROR {
    [ "$LOG_LEVEL" -ge 1 ] && 2>&1 echo "ERROR: $1" && return
}

function INFO {
    [ "$LOG_LEVEL" -ge 2 ] && 2>&1 echo "INFO: $1" && return
}

function WARN {
    [ "$LOG_LEVEL" -ge 3 ] && 2>&1 echo "WARN: $1" && return
}

function DEBUG {
    [ $LOG_LEVEL -ge 4 ] && 2>&1 echo "DEBUG: $1" && return
}

function TRACE {
    [ "$LOG_LEVEL" -ge 5 ] && 2>&1 echo "TRACE: $1" && return
}

function module2path {
    echo "$(echo $1 | perl -npe 's/::/\//g').pm"
}

# look for project home directory from here back, sets PROJECT_HOME
function find_git_home {
    project_home="..";
    git_home=""

    while true; do
        git_home=$(find "$project_home" -type d -path "*/.git");

        PROJECT_HOME=$(cd $project_home; pwd)
        test -n "$git_home" && break;

        project_home="../$project_home"

        if [ "$PROJECT_HOME" = "/" ]; then
            PROJECT_HOME=""
            break;
        fi
    done
}

# cleanup on exit
function cleanup {
    test -n "$NOCLEANUP" && return;
    
    test -n "$testsfile" && rm "$testsfile"
    test -n "$tmp_gitdir" && rm -rf "$tmp_gitdir"
    test -n "$package_files" && rm "$package_files"
    test -n "$exe_files" && rm "$exe_files"

    if test -n "$workdir"; then
        for a in *.tmp; do
            rm -f ${workdir}/$a
        done
    fi

    test -n "$builddir" && rm -rf "$builddir"
}

# default dependency finder
function perl_requires {
    if test -n "@PERL_REQUIRES@"; then
        /usr/lib/rpm/perl.req "$1" | perl -npe 's/^perl\((.*)\)/$1/'
    else
        ERROR "no /usr/lib/rpm/perl.req found!"
        FATAL_ERROR "Install rpm-build package or use the -r option to provide your own dependency checker"
    fi
}

# attempts to grab module versions
function get_module_versions {
    infile="$1"
    
    if ! test -e "$infile"; then
        ERROR "file $infile not found!"
        return;
    fi

    modules=$(mktemp)
    
    sort -u "$infile" | perl -npe 's/^perl\(//; s/\)\s*$//;' >$modules;

    while read -r a; do 
	module="$(echo "$a" | awk '{print $1}')"
	version="$(echo "$a" | awk '{print $2}')"
	
	if test -n "$ANY_VERSION"; then
	    echo "$module 0"
	elif test -n "$a" && ! test -n "$version"; then
	    echo $module | @perlenv@ -I ${perl5libdir} \
            -ne 'chomp; $m=$_; eval "require $m"; $v = eval "\$${m}::VERSION"; print "$m ",$v||0,"\n";' || true;
	else
	    echo "$module $version";
	fi
        
    done <$modules

    rm $modules
}

function scan() {
    scan_target="$1";
    requires_file="$2";
    
    if [ "$PERL_REQUIRES" = "SCANDEPS" ]; then
        if test -z "@scandeps@"; then
            FATA_ERROR "no scandeps.pl found!"
            exit 1
        else
            set -o pipefail
            INFO "Scanning (@scandeps@) $scan_target..."
            if ! @scandeps@ -R $scan_target | perl -npe "s/^\'(.*?)\'.*\$/\$1/;" | awk '{print $1}' >> $requires_files; then
                FATAL_ERROR "could not resolve dependencies for $scan_target"
            else
                DEBUG $(echo "SCAN:" && cat $requires_file)
            fi
        fi
    else
        $PERL_REQUIRES $scan_target >> $requires_file
        DEBUG $(echo "SCAN:" && cat $requires_file)
    fi
}

# +--------------------+
# | SCRIPT STARTS HERE |
# +--------------------+

while getopts "h?Ab:D:e:spg:t:a:m:d:r:l:o:vxf:R:P:zT:L:" arg "$@"; do

    case "${arg}" in

        A)
            ANY_VERSION="1";
            ;;
        e)
            perl5bindir="$OPTARG";
            ;;
        
        z)
            DRYRUN="--dryrun";
            shift;
            ;;
        
        b) BUILDSPEC="$OPTARG";
           ;;
        
        D)
            dependency_file="$OPTARG";
            ;;

        T)
            test_dependency_file="$OPTARG";
            ;;
        
        s)
            PERL_REQUIRES="SCANDEPS"
            ;;

        R)
            recurse_directories="$OPTARG";
            ;;

        P)
            provides="$OPTARG";
            test -n "$provides" && recurse_directories="no"
            ;;

        f)
            EXTRA="$OPTARG";
            ;;

        x)
            NOCLEANUP="1";
            ;;

        p)
            PRESERVE_MAKEFILE="1";
            ;;

        v)
            VERBOSE="1";
            ;;

        o)
            destdir="$OPTARG";
            ;;

        a)
            author="$OPTARG";
            ;;

        h)
	    usage;
	    ;;

        m)
            MODULE="$OPTARG";
            ;;

        d)
            description="$OPTARG";
            ;;

        g)
            git_project="$OPTARG";
            ;;

        l)
            perl5libdir="$OPTARG";
            ;;

        L)
            LOG_LEVEL="$OPTARG";
            ;;
        
        r)
            PERL_REQUIRES="$OPTARG";
            ;;

        t)
            testsdir="$OPTARG";
            ;;
    esac
done

if test -n "$DEBUG"; then
    if [ "$DEBUG" = "1" ]; then
        LOG_LEVEL=4
    elif [ "$DEBUG" = "2" ]; then
        LOG_LEVEL=5
    fi
fi     

LOG_LEVEL=${LOG_LEVEL:-1};
re='^[0-9]+$'

if ! [[ $LOG_LEVEL =~ $re ]] ; then
   FATAL_ERROR "$LOG_LEVEL must be a number between 1 and 5"
fi

[ "$LOG_LEVEL" -ge 4 ] && set -x

shift $((OPTIND -1))

if test -n "$BUILDSPEC"; then
    PROJECT_HOME=$PROJECT_HOME @libexecdir@/make-cpan-dist.pl \
                -b $BUILDSPEC $DRYRUN
    exit $?;
fi

test -z "$MODULE" && usage "no module specified";
test -z "$author" && usage "no author specified";
test -z "$description" && usage "no description";

recurse_directories=${recurse_directories:-yes}

# tarball destination directory
destdir=${destdir:-$(pwd)}

if test -n "$git_project"; then
    tmp_gitdir=$(mktemp -d)
    PROJECT_HOME=$tmp_gitdir
    git clone $git_project $PROJECT_HOME
    cd $PROJECT_HOME
    set -e -o pipeline
    if test -e configure.ac; then
        autoreconf -i --force && ./configure --with-perlibdir=yes && make
    fi
else
    PROJECT_HOME=$(pwd)
fi

if test -z "$PROJECT_HOME"; then
    usage "could not find project home"
fi

# typical directory within project tree containing Perl modules
perl5libdir=${perl5libdir:-src/main/perl/lib}

# program that will provide the dependency list
PERL_REQUIRES=${PERL_REQUIRES:-perl_requires}

builddir=$(mktemp -d)

trap cleanup EXIT

module_file="$(module2path $MODULE)"

mkdir -p ${builddir}/lib/$(dirname $module_file);
    
if ! test -e "${PROJECT_HOME}/${perl5libdir}/$module_file"; then
    FATAL_ERROR "no "${PROJECT_HOME}/${perl5libdir}/$module_file" found!"
fi

if test -n "$EXTRA"; then
    if test -s "$EXTRA"; then
        while IFS=' ' read -r a b
        do
            INFO "$a $b"
            
            if [ -f "$a" ]; then
                if test -n "$b"; then
                   dir=$(dirname $b)
                   test -d $dir || mkdir -p $builddir/$dir
                fi
                cp $a $builddir/$dir
            else
                ERROR "file [$a] not found?"
                exit 1
            fi
        done <"$EXTRA"
    else
        WARN "No EXTRA file ($EXTRA) found in $(pwd)!"
    fi
fi

workdir=$(pwd)
package_files=$(mktemp);
exe_files=$(mktemp);

if [ ! "$recurse_directories" = "yes" ]; then
    maxdepth='-maxdepth 1'
fi

if test -n "$perl5bindir"; then
    find ${PROJECT_HOME}/${perl5bindir} $maxdepth -name '*.pl' > $exe_files;
    find ${PROJECT_HOME}/${perl5bindir} $maxdepth -name '*.sh' >> $exe_files;
fi

# set 'recurse' to 'no' and 'provides' to some value to specify your
# own set of files to package
if [ "$recurse_directories" = "yes" ]; then
    find ${PROJECT_HOME}/${perl5libdir} -name '*.pm' > $package_files;
else
    if test -n "$provides"; then
        if test -s "$provides"; then
            echo "$MODULE" >>$provides
            for a in $(cat $provides) "$module_file"; do
                echo "${PROJECT_HOME}/${perl5libdir}/$(module2path $a)" >> $package_files
            done

        else
            FATAL_ERROR "Empty provides file"
        fi
    else
        # must package the module at least?
        echo "${PROJECT_HOME}/${perl5libdir}/$module_file" >$package_files
    fi
fi

for a in $(cat $package_files | sort -u); do
    DEBUG "provides: [$a]"
    
    required_module=${a##${PROJECT_HOME}/${perl5libdir}/}
    echo $required_module >> ${workdir}/provides.tmp
    
    mkdir -p $(dirname ${builddir}/lib/$required_module)
    cp $a ${builddir}/lib/$required_module
done

if test -s "$exe_files"; then
    mkdir -p ${builddir}/bin
    
    for a in $(cat $exe_files); do
        cp $a ${builddir}/bin
    done
fi

if test -z "$dependency_file"; then

    for a in $(cat $package_files | sort -u); do
        scan $a ${workdir}/requires.tmp;
    done
    
    # find dependencies for .pl files
    if test -s "$exe_files"; then
        for a in $(cat $exe_files); do
            scan $a ${workdir}/requires.tmp;
        done
    fi
else
    if [ $(basename $dependency_file) = "cpanfile" ]; then
        if test -n $(which cpanfile-dump 2>/dev/null); then
            cpanfile-dump "$dependency_file" >${workdir}/requires.tmp
        else
            WARN "cpanfile-dump not found!"
        fi
    else
        cat $dependency_file > ${workdir}/requires.tmp
    fi
fi

if ! test -s ${workdir}/requires.tmp; then
    WARN "no dependencies will be listed for this distribution!"
    touch ${workdir}/requires.tmp
fi

cat ${workdir}/provides.tmp | perl -npe 's/\//::/g; s/\.pm$//;' | sort -u > ${workdir}/provides

# should we resolve versions here or in Perl module?
# echo "$(get_module_versions ${workdir}/provides)" > ${workdir}/provides

sort -u ${workdir}/requires.tmp > ${workdir}/requires

# remove provided files from required list
comm -23 ${workdir}/requires ${workdir}/provides > ${workdir}/requires.tmp

# get the module versions we are currently using

if test -z "$dependency_file"; then
    get_module_versions ${workdir}/requires.tmp > ${workdir}/requires
fi

if test -n "$test_dependency_file"; then
    cp $test_dependency_file ${workdir}/test-requires.tmp
    cp ${workdir}/test-requires.tmp {workdir}/test-requires
else
    if test -n "$testsdir"; then
        if test -d "$testsdir"; then
            testsfile=$(mktemp);
            ls -1 ${testsdir}/*.t >$testsfile 2>/dev/null || true
            if test -s "$testsfile"; then
                mkdir ${builddir}/t
                
                for a in $(cat $testsfile); do
                    cp $PROJECT_HOME/$a ${builddir}/t/
                    scan $PROJECT_HOME/$a ${workdir}/test-requires.tmp
                done
                
                # remove provided files from required list
                sort -u ${workdir}/test-requires.tmp > ${workdir}/test-requires
                comm -23 ${workdir}/test-requires ${workdir}/provides > ${workdir}/test-requires.tmp
                # get module versions for test-requires
                get_module_versions test-requires.tmp > ${workdir}/test-requires
            else
                rm -f "$testsfile";
                testsfile="";
            fi
        fi
    fi
fi

test -n "$VERBOSE" && cat ${workdir}/requires
test -n "$VERBOSE" && test -e ${workdir}/test-requires && cat ${workdir}/test-requires

# create the Makefile.PL
if ! PROJECT_HOME=$PROJECT_HOME @libexecdir@/make-cpan-dist.pl \
            -r ${workdir}/requires \
            -e $exe_files \
            -t ${workdir}/test-requires \
            -w ${builddir} \
            -l $LOG_LEVEL \
            -m "$MODULE" \
            -A "$description" \
            -a "$author" > $builddir/Makefile.PL; then
    ERROR "could not successfully create Makefile.PL"
    exit 1
fi

# if that was successful, then try to build the distribution
if ! test -e $builddir/Makefile.PL; then
    FATAL_ERROR "failed to build Makefile.PL"
    exit 1;
else
    cd $builddir
    test -n "$VERBOSE" && tree
    test -n "$VERBOSE" && cat Makefile.PL
    
    if perl Makefile.PL; then
        make manifest
        make dist
        cp *.tar.gz $destdir
        make test
        if test -n "$PRESERVE_MAKEFILE"; then
            cp Makefile.PL $destdir
        fi
        
        echo "CPAN authors: cpan-upload-http $(ls -1rt *.tar.gz | tail -1)"
    fi
fi

exit 0;
