#!@perlrun@

package CPAN::Maker;

# a CPAN distribution creation utility

use strict;
use warnings;

use CPAN::Maker::Constants qw{ :all };
use CPAN::Maker::Utils qw{ :all };
use Carp;
use Data::Dumper;
use English qw{ -no_match_vars };
use ExtUtils::MM;
use File::Basename;
use File::Find;
use File::Process qw{ process_file filter };
use File::Temp qw{ :POSIX };
use Getopt::Long qw{:config no_ignore_case };
use JSON::PP qw{ encode_json decode_json };
use List::Util qw{ pairs };
use Log::Log4perl qw{ :easy };
use Log::Log4perl::Level;
use Pod::Usage;
use Scalar::Util qw{ reftype };
use YAML::Tiny;
use version;

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)

caller or __PACKAGE__->main();

########################################################################
sub help {
########################################################################
  print <<"END_OF_TEXT";
usage: $PROGRAM_NAME OPTIONS

Example: $PROGRAM_NAME -m Some::Module -a 'Rob Lauer <rlauer6\@comcast.net>' -d 'my wonderful module'

OPTIONS
-------
-c, --cleanup             cleanup files, this is default
    --no-cleanup
-a, --author              author
-A, --any                 do not require a version
-B, --build-requires      build dependencies
-b, --buildspec           read a buildspec and create command line
-d, --abstract            abstract
-l, --log-level           ERROR, WARN, INFO, DEBUG, TRACE
-m, --module              module name
-M, --module-list         list of modules to include in distribution
-r, --requires            dependency list
-R, --require-versions    add version numbers to dependencies
    --no-require-versions
-t, --test-requires       test dependencies
-s, --scandeps            use scandeps for dependency checking
-v, --version             version

Typically, this script is called from the bash helper script of the same
name (make-cpan-dist) or is invoked with a YAML file that specifies
the parmeters used to build a distribution.

See https://github.com/rlauer6/make-cpan-dist.git for more documentation.

See man make-cpan-dist

Version: $VERSION

END_OF_TEXT
  return $SH_FAILURE;
} ## end sub help

########################################################################
sub get_exe_file_list {
########################################################################
  my ($file) = @_;

  my $lines;
  if ($file) {
    ($lines) = process_file(
      $file,
      chomp            => $TRUE,
      skip_blank_lines => $TRUE,
      process          => sub {
        my $f = pop @_;
        $f =~ s/^.*\/(.*)$/bin\/$1/xsm;
        return $f;
      }
    );
  } ## end if ($file)

  return $lines ? @{$lines} : ();
} ## end sub get_exe_file_list

########################################################################
sub get_provides {
########################################################################
  my ( $file, %options ) = @_;

  my %provides;

  if ($file) {
    my ($lines) = process_file(
      $file,
      chomp            => $TRUE,
      skip_blank_lines => $TRUE,
      prefix           => 'lib',
      process          => sub {
        my $module = pop @_;
        my $args   = pop @_;

        if ( !$module ) {
          return ();
        } ## end if ( !$module )

        my $include_path = $args->{'prefix'};

        if ( $options{'work-dir'} ) {
          $include_path = $options{'work-dir'} . $SLASH . $include_path;
        } ## end if ( $options{'work-dir'...})

        my $module_version = get_module_version( $module, $include_path );

        my ( $provided_module, $version )
          = @{$module_version}{qw{ module version}};

        croak "$module not found in $include_path"
          if !defined $version;

        $provides{$provided_module} = {
          file    => $args->{prefix} . $SLASH . $module_version->{'file'},
          version => $version,
        };

        return $provided_module;
      }
    );
  } ## end if ($file)
  return %provides;
} ## end sub get_provides

########################################################################
sub get_resources {
########################################################################
  goto &get_json_file;
} ## end sub get_resources

########################################################################
sub get_json_file {
########################################################################
  my ($file) = @_;

  my ($json) = process_file(
    $file,
    chomp       => 1,
    merge_lines => 1
  );

  return decode_json($json);
} ## end sub get_json_file

########################################################################
sub write_resources {
########################################################################
  my ( $resources, %args ) = @_;

  my $resources_file;

  if ($resources) {
    $resources_file = 'resources';

    open my $fh, '>', $resources_file
      or croak "could not open resources for writing\n";

    print {$fh} encode_json($resources);

    close $fh
      or croak "could not close file $resources_file\n";
  } ## end if ($resources)

  return %args;
} ## end sub write_resources

########################################################################
sub write_provides {
########################################################################
  my ( $provides, %args ) = @_;

  my $provides_file;

  if ($provides) {
    $provides_file = 'provides';

    open my $fh, '>', $provides_file
      or croak "could not open 'provides' for writing\n";

    foreach my $file ( @{$provides} ) {
      print {$fh} "$file\n";
    } ## end foreach my $file ( @{$provides...})

    close $fh
      or croak "could not close 'provides'\n";

    $args{P} = $provides_file;
  } ## end if ($provides)

  return %args;
} ## end sub write_provides

########################################################################
sub write_makefile {
########################################################################
  my (%options) = @_;

  my $core            = $options{'core-modules'};
  my $module_abstract = $options{'abstract'};
  my $author          = $options{'author'};

  my $module = 'lib/' . make_path_from_module( $options{'module'} );

  local $Data::Dumper::Terse    = $TRUE;
  local $Data::Dumper::Sortkeys = $TRUE;
  local $Data::Dumper::Indent   = 2;
  local $Data::Dumper::Pad      = $SPACE x $INDENT;

  # dependencies
  foreach my $d (qw{requires test-requires build-require }) {
    $options{$d} = $options{$d} || $d;
  } ## end foreach my $d (qw{requires test-requires build-require })

  my $pre_req = Dumper get_requires( $options{'requires'}, $core,
    $options{'min-perl-version'} );
  $pre_req = trim($pre_req);

  my $test_req = {};

  if ( $options{'test-requires'} && -s $options{'test-requires'} ) {
    $test_req = Dumper get_requires( $options{'test-requires'},
      $core, $options{'min-perl-version'} );
  } ## end if ( $options{'test-requires'...})
  else {
    $test_req = '{}';
  } ## end else [ if ( $options{'test-requires'...})]

  $test_req = trim($test_req);

  my $build_req = {};

  if ( $options{'build-requires'} && -s $options{'build-requires'} ) {
    $build_req = Dumper get_requires( $options{'build-requires'},
      $TRUE, $options{'min-perl-version'} );
    $build_req = trim($build_req);
  } ## end if ( $options{'build-requires'...})

  foreach my $m (qw{ ExtUtils::MakeMaker File::ShareDir::Install}) {
    $build_req->{$m} = $build_req->{$m} || $FALSE;
  } ## end foreach my $m (qw{ ExtUtils::MakeMaker File::ShareDir::Install})

  $build_req = Dumper $build_req;

  my @exe_file_list;

  if ( $options{'exe-files'} && -s $options{'exe-files'} ) {
    @exe_file_list = get_exe_file_list( $options{'exe-files'} );
  } ## end if ( $options{'exe-files'...})

  my $exe_files = Dumper \@exe_file_list;

  my %provides;

  if ( -e 'provides' ) {
    %provides = get_provides( 'provides', %options );
  } ## end if ( -e 'provides' )

  my $resources;

  if ( -e 'resources' ) {
    $resources = get_resources('resources');
  } ## end if ( -e 'resources' )

  my $META_MERGE = 'META_MERGE ' . $FAT_ARROW;

  {
    local $Data::Dumper::Pair = $FAT_ARROW;

    $META_MERGE .= Dumper(
      { 'meta-spec' => { version => 2 },
        'provides'  => \%provides,
        $resources ? ( 'resources' => $resources ) : ()
      }
    );
  }

  my $timestamp        = scalar localtime;
  my $min_perl_version = $options{'min-perl-version'};

  my $MAKEFILE = <<"END_OF_TEXT";
# autogenerated by $PROGRAM_NAME on $timestamp

use strict;
use warnings;

use ExtUtils::MakeMaker;
use File::ShareDir::Install;

if ( -d 'share' ) {
  install_share 'share';
}

WriteMakefile(
   NAME           => '$options{module}',
  MIN_PERL_VERSION => $min_perl_version,
  AUTHOR         => '$author',
  VERSION_FROM   => '$module',
  ABSTRACT       => '$module_abstract',
  LICENSE        => 'perl',
  PL_FILES       => {},
  EXE_FILES      => $exe_files,
  PREREQ_PM      => $pre_req,
  BUILD_REQUIRES => {
    'ExtUtils::MakeMaker'     => '6.64',
    'File::ShareDir::Install' => $NO_VERSION,
    },
  CONFIGURE_REQUIRES => {
    'ExtUtils::MakeMaker'     => '6.64',
    'File::ShareDir::Install' => $NO_VERSION,
    },
  TEST_REQUIRES => $test_req,
  $META_MERGE
);

package MY;

use File::ShareDir::Install qw( postamble );

END_OF_TEXT

  print $MAKEFILE;

  DEBUG sub { return $MAKEFILE };

  return $SUCCESS;
} ## end sub write_makefile

########################################################################
sub write_file_list {
########################################################################
  my ( $file_list, $destdir ) = @_;

  my @expanded_list;

  for my $f ( @{$file_list} ) {
    if ( -d $f ) {
      find(
        sub {
          if ( !/^[.]+$/xsm ) {
            push @expanded_list, "$File::Find::name $destdir/$_";
          } ## end if ( !/^[.]+$/xsm )
        },
        $f
      );
    } ## end if ( -d $f )
    else {
      # the intent is to cp files to root of distribution (not
      # to install the files during package installation...the
      # exception being if items are installed into share
      # directory
      my ( $name, $path, $ext ) = fileparse( $f, qr/[.][^.]*/xsm );
      push @expanded_list, "$f $destdir/$name$ext\n";
    } ## end else [ if ( -d $f ) ]
  } ## end for my $f ( @{$file_list...})

  return @expanded_list;
} ## end sub write_file_list

# file name or hash
# extra-files:
#   share:
#     - ../README.md
#     - ../ChangeLog
#   examples: ../src/examples
# extra-files:
#   - file

########################################################################
sub write_extra_files {
########################################################################
  my ( $extra_files, $extra, %args ) = @_;

  return %args
    if !ref $extra_files || reftype($extra_files) ne 'ARRAY';

  my $extra_files_path = $extra || 'extra-files';

  my @file_list;

  foreach my $e ( @{$extra_files} ) {

    if ( !ref $e ) {
      push @file_list, $e;
    } ## end if ( !ref $e )
    elsif ( reftype($e) eq 'HASH' ) {
      my ($destdir) = keys %{$e};

      if ( $destdir !~ /\/$/xsm ) {
        $destdir .= $SLASH;
      } ## end if ( $destdir !~ /\/$/xsm)

      my $file_list = $e;

      if ( ref($file_list) && reftype($file_list) ne 'ARRAY' ) {
        $file_list = [ values %{$file_list} ];
      } ## end if ( ref($file_list) &&...)
      elsif ( !ref $file_list ) {
        $file_list = [$file_list];
      } ## end elsif ( !ref $file_list )

      push @file_list, write_file_list( $file_list, $destdir );

    } ## end elsif ( reftype($e) eq 'HASH')
  } ## end foreach my $e ( @{$extra_files...})

  open my $fh, '>', $extra_files_path
    or croak "could not append to $extra_files_path\n";

  foreach my $f (@file_list) {
    print {$fh} "$f\n";
  } ## end foreach my $f (@file_list)

  close $fh
    or croak "could not close $extra_files_path\n";

  $args{f} = $extra_files_path;

  return %args;
} ## end sub write_extra_files

########################################################################
sub parse_path {
########################################################################
  my ( $path, %args ) = @_;

  if ($path) {
    if ( $path->{'recurse'}
      && $path->{'recurse'} =~ /(yes|no)/ixsm ) {
      $args{R} = $path->{'recurse'};
    } ## end if ( $path->{'recurse'...})
    elsif ( $path->{'recurse'} ) {
      croak "use only yes or no for 'recurse' option\n";
    } ## end elsif ( $path->{'recurse'...})

    # -l
    if ( $path->{'pm_module'} ) {
      $args{l} = $path->{'pm_module'};
    } ## end if ( $path->{'pm_module'...})

    # -e
    if ( $path->{'exe_files'} ) {
      $args{e} = $path->{'exe_files'};
    } ## end if ( $path->{'exe_files'...})

    # -t
    if ( $path->{'tests'} ) {
      $args{t} = $path->{'tests'};
    } ## end if ( $path->{'tests'} )
  } ## end if ($path)
  return %args;
} ## end sub parse_path

########################################################################
sub parse_dependencies {
########################################################################
  my ( $dependencies, %args ) = @_;

  if ($dependencies) {

    if ( $dependencies->{'path'} ) { # deprecatd
      $args{D} = $dependencies->{'path'};
      warn "path is deprecated: use requires\n";
    } ## end if ( $dependencies->{'path'...})

    if ( $dependencies->{'requires'} ) {
      $args{D} = $dependencies->{'requires'};
    } ## end if ( $dependencies->{'requires'...})

    if ( $dependencies->{'test_requires'} ) {
      $args{T} = $dependencies->{'test_requires'};
    } ## end if ( $dependencies->{'test_requires'...})

    if ( $dependencies->{'build_requires'} ) {
      $args{B} = $dependencies->{'build_requires'};
    } ## end if ( $dependencies->{'build_requires'...})

    if ( $dependencies->{'core_modules'} eq 'yes' ) {
      $args{c} = $EMPTY;
    } ## end if ( $dependencies->{'core_modules'...})

    if ( my $resolver = $dependencies->{'resolver'} ) {
      if ( $resolver eq 'scandeps' ) {
        $args{s} = $EMPTY;
      } ## end if ( $resolver eq 'scandeps')
      else {
        $args{r} = $dependencies->{'resolver'};
      } ## end else [ if ( $resolver eq 'scandeps')]
    } ## end if ( my $resolver = $dependencies...)

    if ( $args{D} && $args{r} ) {
      croak "use either path or resolver for dependencies, but not both\n";
    } ## end if ( $args{D} && $args...)
  } ## end if ($dependencies)

  return %args;
} ## end sub parse_dependencies

########################################################################
sub parse_include_version {
########################################################################
  my ( $version, %args ) = @_;

  if ( defined $version ) {
    if ( $version =~ /(no|0|off)/xsm ) {
      $args{A} = $EMPTY;
    } ## end if ( $version =~ /(no|0|off)/xsm)
  } ## end if ( defined $version )
  return %args;
} ## end sub parse_include_version

########################################################################
sub parse_project {
########################################################################
  my ( $project, %args ) = @_;

  if ($project) {
    if ( $project->{'author'} ) {
      $args{a} = $project->{'author'}->{'name'};

      if ( $project->{'author'}->{'mailto'} ) {
        $args{a} .= ' <' . $project->{'author'}->{'mailto'} . '>';
      } ## end if ( $project->{'author'...})

      $args{a} = sprintf q{'%s'}, $args{a};
    } ## end if ( $project->{'author'...})

    # -d
    if ( $project->{'description'} ) {
      $args{d} = sprintf q{'%s'}, $project->{'description'};
    } ## end if ( $project->{'description'...})

    # -g
    if ( $project->{'git'} ) {
      $args{g} = $project->{'git'};
    } ## end if ( $project->{'git'})
  } ## end if ($project)

  return %args;
} ## end sub parse_project

########################################################################
sub parse_pm_module {
########################################################################
  my ( $pm_module, %args ) = @_;

  if ($pm_module) {
    $args{m} = $pm_module;
  } ## end if ($pm_module)
  return %args;
} ## end sub parse_pm_module

########################################################################
sub get_buildspec {
########################################################################
  my ($file) = @_;

  croak 'file not found or empty ' . $file . $NL
    if !-s $file;

  my $buildspec = eval { YAML::Tiny->read($file)->[0]; };

  croak 'could not read ' . $file . $NL . $EVAL_ERROR . $NL
    if $EVAL_ERROR || !$buildspec;

  return $buildspec;
} ## end sub get_buildspec

########################################################################
sub parse_buildspec {
########################################################################
  my (%options) = @_;

  my $file = $options{buildspec};

  my $buildspec = get_buildspec($file);

  croak 'bad build file'
    if !validate_object( $buildspec, $options{'yaml-spec'} );

  my %args;

  %args = parse_project( $buildspec->{project}, %args );

  %args = parse_pm_module( $buildspec->{'pm_module'}, %args );

  %args = parse_include_version( $buildspec->{'include-version'}, %args );

  %args = parse_dependencies( $buildspec->{'dependencies'}, %args );

  %args = parse_path( $buildspec->{path}, %args );

  %args = write_extra_files( $buildspec->{'extra-files'},
    $buildspec->{'extra'}, %args );

  %args = write_provides( $buildspec->{'provides'}, %args );

  %args = write_resources( $buildspec->{'resources'}, %args );

  # set boolean args from options

  my @boolean_args
    = qw{ verbose v cleanup !x scandeps s require-versions !A };

  foreach my $pair ( pairs @boolean_args ) {
    my ( $key, $value ) = @{$pair};

    if ( $value =~ /^\!(.*)$/xsm ) {
      if ( $options{$1} ) {
        delete $options{$1};
      } ## end if ( $options{$1} )
    } ## end if ( $value =~ /^\!(.*)$/xsm)
    elsif ( $options{$key} ) {
      $args{$value} = $EMPTY;
    } ## end elsif ( $options{$key} )
  } ## end foreach my $pair ( pairs @boolean_args)

  # set value args from buildspec
  foreach my $pair ( pairs qw{ destdir o extra f } ) {
    my ( $key, $value ) = @{$pair};

    if ( $buildspec->{$key} ) {
      $args{$value} = $buildspec->{$key};
    } ## end if ( $buildspec->{$key...})
  } ## end foreach my $pair ( pairs qw{ destdir o extra f })

  foreach my $k ( keys %args ) {
    $args{ $DASH . $k } = $args{$k};
    delete $args{$k};
  } ## end foreach my $k ( keys %args )

  return %args;
} ## end sub parse_buildspec

########################################################################
sub get_requires {
########################################################################
  my ( $requires, $core_modules, $min_perl_version ) = @_;

  my %modules;

  process_file(
    $requires,
    chomp            => $TRUE,
    skip_blank_lines => $TRUE,
    filter           => sub {
      my ( $fh, $all_lines, $args, $line ) = @_;
      $line = filter( $fh, $all_lines, $args, $line );

      return $line if !defined $line;
      return $line if $core_modules;
      return $line if $line =~ /^[+]/xsm;

      return is_core( $line, $min_perl_version )
        ? undef
        : $line;
    },
    process => sub {
      my $line = pop @_;

      $line =~ s/^[+]([^+]*)$/$1/xsm;

      my ( $module, $version ) = split /\s/xsm, $line;
      $version = $version || '0';

      $modules{$module} = $version;

      return $line;
    }
  );

  return \%modules;
} ## end sub get_requires

########################################################################
sub get_modules {
########################################################################
  my ($module_list) = @_;

  my ($modules) = process_file( $module_list, chomp => $TRUE );

  return $modules;
} ## end sub get_modules

########################################################################
sub get_yaml_specfile {
########################################################################
  my ($options) = @_;

  my ($lines) = process_file(
    *DATA,
    chomp     => $TRUE,
    next_line => sub {
      my ( $fh, $all_lines, $args ) = @_;

      my $line = <$fh>;

      return if $line =~ /^\=pod/xsm; # signal end of file

      return $line;
    }
  );

  return Load join "\n", @{$lines};
} ## end sub get_yaml_specfile

########################################################################
sub validate_object {
########################################################################
  my ( $obj, $spec, $err ) = @_;

  $err = $err // 0;

  if ( reftype($obj) eq 'HASH' ) {
    foreach my $k ( keys %{$obj} ) {
      if ( !exists $spec->{$k} ) {
        carp "ERROR: not a valid key ($k)\n" . Dumper [ $k, $spec ];
        $err++;
      } ## end if ( !exists $spec->{$k...})

      if ( ref $spec->{$k} ) {
        if ( !ref $obj->{$k}
          || reftype( $obj->{$k} ) ne reftype( $spec->{$k} ) ) {
          warn "ERROR: wrong type for ($k) - $k must be "
            . reftype( $spec->{$k} ) . "\n";
          $err++;
        } ## end if ( !ref $obj->{$k} ||...)
        else {
          validate_object( $obj->{$k}, $spec->{$k}, $err );
        } ## end else [ if ( !ref $obj->{$k} ||...)]
      } ## end if ( ref $spec->{$k} )
    } ## end foreach my $k ( keys %{$obj...})
  } ## end if ( reftype($obj) eq ...)
  else { # just validate arrays are arrays for now, deep dive TBD
    $err = reftype($spec) eq 'ARRAY';
  } ## end else [ if ( reftype($obj) eq ...)]

  return $err ? $FALSE : $TRUE;
} ## end sub validate_object

# +-------------------------+
# | MAIN SCRIPT STARTS HERE |
# +-------------------------+

sub main {
  my %options = ( cleanup => 1 );

  GetOptions(
    \%options,              'abstract|A=s',
    'author|a=s',           'buildspec|b=s',
    'build-requires|B=s',   'cleanup!',
    'core-modules!',        'dryrun',
    'debug|D',              'exe-files=s',
    'help|h',               'log-level|l=s',
    'module|m=s',           'require-versions!',
    'min-perl-version|M=s', 'requires|r=s',
    'scandeps|s',           'test-requires=s',
    'verbose|V',            'version|v',
    'work-dir|w=s',
  );

  if ( $options{help} ) {
    help;
  } ## end if ( $options{help} )

  $options{'yaml-spec'} = get_yaml_specfile;

  if ( $options{'min-perl-version'} ) {
    $options{'min-perl-version'}
      = version->parse( $options{'min-perl-version'} )->stringify;
  } ## end if ( $options{'min-perl-version'...})
  else {
    $options{'min-perl-version'} = $DEFAULT_PERL_VERSION;
  } ## end else [ if ( $options{'min-perl-version'...})]

  if ( !exists $options{'require-versions'} ) {
    $options{'require-versions'} = $TRUE;
  } ## end if ( !exists $options{...})

  if ( $options{'version'} ) {
    print $PROGRAM_NAME . ' v' . $VERSION . $NL;

    exit $SH_SUCCESS;
  } ## end if ( $options{'version'...})

  my $log_level = $options{'log-level'};

  if ($log_level) {
    if ( $log_level =~ /\A[1-5]\z$/xsm ) {
      $log_level = ( $ERROR, $WARN, $INFO, $DEBUG, $TRACE )[ $log_level - 1 ];
    } ## end if ( $log_level =~ /\A[1-5]\z$/xsm)
    else {
      $log_level = {
        ERROR => $ERROR,
        WARN  => $WARN,
        INFO  => $INFO,
        DEBUG => $DEBUG,
        TRACE => $TRACE,
      }->{ uc $options{'log-level'} };
    } ## end else [ if ( $log_level =~ /\A[1-5]\z$/xsm)]

    if ( !$log_level ) {
      $log_level = $ERROR;
    } ## end if ( !$log_level )

    Log::Log4perl->easy_init($log_level);
  } ## end if ($log_level)

  if ( $options{buildspec} ) {
    my %args = parse_buildspec(%options);

    if ($log_level) {
      $args{'-L'} = {
        $ERROR => 1,
        $WARN  => 2,
        $INFO  => 3,
        $DEBUG => 4,
        $TRACE => 5,
      }->{$log_level};
    } ## end if ($log_level)

    if ( !$options{'dryrun'} ) {
      exec '@bindir@/make-cpan-dist ' . join $SPACE, %args; ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)
    } ## end if ( !$options{'dryrun'...})
    else {
      print '@bindir@/make-cpan-dist ' . ( join $SPACE, %args ) . $NL; ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)
    } ## end else [ if ( !$options{'dryrun'...})]
  } ## end if ( $options{buildspec...})
  else {
    croak 'no module specified'
      if !$options{'module'};

    croak 'no dependencies'
      if !$options{'requires'};

    $options{'author'} = $options{'author'}
      // 'Anonyous <anonymous@example.com>';
    $options{'abstract'} = $options{'abstract'} // 'my awesome Perl module!';

    if ( !write_makefile(%options) ) {
      help();
      exit $SH_FAILURE;
    } ## end if ( !write_makefile(%options...))
  } ## end else [ if ( $options{buildspec...})]

  exit $SH_SUCCESS;
} ## end sub main

1;

__DATA__
---
version: "@PACKAGE_VERSION@"
project:
  git: "type:string"
  description: "type:string"
  author:
    name: "type:string"
    mailto: "type:string"
pm_module:
include-version: "type:boolean"
dependencies:
  resolver: "type:string"
  path: "type:string"
  requires: "type:string"
  test_requires: "type:string"
  build_requires: "type:string"
  core_modules: "type::boolean"
path:
  recurse: "type:boolean"
  pm_module: "type:string"
  tests: "type:string"
  exe_files: "type:string"
destdir: "type:string"
extra: "type:string"
extra-files:
provides: "type:string"
resources:
  homepage: "type:string"
  bugtracker:
    web: "type:string"
    mailto: "type:string"
  repository:
    url: "type:string"
    web: "type:string"
    type: "type:string"

=pod

=head1 NAME

make-cpan-spec.pl

=head1 SYNOPSIS

 make-cpan-dist.pl options

 make-cpan-dist.pl \
   --module Some::Module \
   --author 'Rob Lauer <rlauer6@comcast.net>' \
   --abstract 'my wonderful module'

=head1 DESCRIPTION

Utility that is part of the toolchain to create a simple CPAN
distribution. This utility is typically called from the C<bash> helper
script of the same name or can be passed a build specfication file in
YAML format. You may I<not> find this easier to use than crafting your
own CPAN distributions with the various tools available for
such.

The helper script (F<make-cpan-dist>) does most of the heavy lifting,
doing things for you like attempting to resolve dependencies and
packaging the distribution as a tarball.

In general you should consider using the C<bash> script or create a
F<buildspec.yml> file and invoke this utility with the C<-b> option
described below rather than calling this script directly.

=head2 Using the Bash Script

Assuming you have a module named C<Foo::Bar> in a directory named
F<lib> and some tests in a directory named F<t>, you might try:

 make-cpan-dist -l lib -t t -m Foo::Bar \
  -a 'Rob Lauer <rlauer6@comcast.net>' -d 'the Foo::Bar module!'

=head2 Using F<buildspec.yml>

 make-cpan-dist.pl -b buildspec.yml

Calling this utility directly with the C<-b> option will invoke the
C<bash> script and is probably the preferred way of using this
toolchain. The format of the YAML build file is described below.

If you insist on using this utility directly anyway, read on.

=head1 OPTIONS

=over 5

=item -A, --abstract

Short description of the module purpose.

=item -a, --author

When supplying the author on the command line, include the email
address in angle brackets as shown in the example.

Example: -a 'Rob Lauer <rlauer6@comcast.net>'

=item -B, --build-requires

Name of the dependeny file list for building the distribution.

=item -b, --buildspec

Name of a build specification file.  The build specification file is
used B<instead> of options. See L</Build Specificaton Format>.

=item -c, --cleanup

Cleanup temp directories and files.  Default is to cleanup, use
--no-cleanup if you want to examine some of the temporary files.

=item -l, --log-level

Log level.

Valid values: error|warn|info|debug

=item -m, --module

Name of the module

=item -M, --module-list

List of modules to include in distribution

=item -R, --require-versions, --no-require-versions

Whether to add version numbers to dependencies.

default: --require-versions

=item -r, --requires

Name of the dependency file list if other than F<requires>.

=item -s, --scandeps

Use scandeps for dependency checking

=item -t, --test-requires

Name of the test dependencies file if other than F<test-requires>.

=item -v, --version

Returns the version of this script

=back

Note: Set the environment variable C<PRESERVE_MAKEFILE> if you want
the script to preserve the F<Makefile.PL>.  It will be copied to your
current working directory.

=head1 Build File Format

  version: @PACKAGE_VERSION@
  project:
    git: https://github.com/rlauer6/perl-Amazon-Credentials
    description: "AWS credentials discoverer"
    author:
      name: Rob Lauer
      mailto: rlauer6@comcast.net
  pm_module: Amazon::Credentials
  include-version: no
  dependencies:
    resolver: scandeps
    path: requires
    requires: requires
    test_requires: test-requires
  path:
    recurse: yes
    pm_module: src/main/perl/lib
    tests: src/main/perl/t
    exe_files: src/main/perl/bin
  destdir: 
  extra: extra-files
  extra-files:
    -file
    /usr/local/share/my-project: file
    /usr/local/share/my-project:
      -file
  provides: provides
  resources:
    homepage: 'http://github.com/rlauer6/perl-Amazon-API'
    bugtracker:
      web: 'http://github.com/rlauer6/perl-Amazon-API/issues'
      mailto: rlauer6@comcast.net
    repository:
      url: 'git://github.com/rlauer6/perl-Amazon-API.git'
      web: 'http://github.com/rlauer6/perl-Amazon-API'
      type: 'git'

The sections are described below:

=over 10

=item project

=over 15

=item git

The path to the C<git> project. When the project is cloned, the
utility will look for F<configure.ac> and if found will attempt to
build the project in usual I<autoconfiscated> manner:

 git clone {project}
 autoconf -i --force
 ./configure
 make

...otherwise the project will simply be cloned and it will be assumed
the Perl module is somewhere to be found in the project tree.  You
should make sure that you set the C<path> section accordingly so that
the utility now knows were to find your Perl module though.

=item description

The description of the module as it will be appear in the CPAN
repository.

=item author

The I<author> section should contain a name and email address.

=over 20

=item name

The author's name.

=item mailto

The author's email address.

=back

=back

=item pm_module

The name of the Perl module.

=item include-version

If dependencies are resolved automatically include the version
number. To disable set to no.

default: yes

=item dependencies (optional)

The I<dependencies> section, if present may contain the fully
qualified path to a file that contains a list of dependencies. If
the name of the file is F<cpanfile>, then the file is assumed to be in
I<cpanfile> format, otherwise the file should be a simple list of Perl
module names optionally followed by a version number.

 Amazon::Credentials 1.15

By default, the scripts will look for F</usr/lib/rpm/perl.req> as the
dependency resolver, however you can override this by specifying the
name of program that will produce a list of modules.  If you specify
the special name I<scandeps>, the scripts will use F<scandeps.pl>.

=over 15

=item path (deprecated)

=item requires

Fully qualified path to a dependency list for module.

=item test_requires

Fully qualified path to a dependency list for tests.

=item build_requires

Fully qualified path to a dependency list for build.

=item resolver (optional)

Name of a program that will provide a list of depenencies when passed
a module name. Use the special name C<scandeps> to use Perl's
C<scandeps.pl>.  When using C<scandeps.pl>, the C<-R> option will be
used to prevent C<scandeps.pl> from recursing. Neither
C</usr/lib/rpm/perl.req> or C<scandeps.pl> are completely
reliable. Your methodology might be to use these to get a good start
on a file containing dependencies and then add/subtract as required
for your use case.

When preparing the list of files to list as requirements in the
C<PREREQ_PM> section of the C<Makefile.PL>, the script will
automatically remove any modules that are already included with Perl.

=back

=item path (optional)

=over 15

=item pm_module

The path where the Perl module to be packaged can be found.  By
default, the current working directory will be searched.

=item recurse (optional)

Specifies whether to or not to looks in subdirectories of path
specified by C<pm_module> for additional modules to package.  The
default is 'yes'.  Valid values are "yes" or "no".

=item tests (optional)

The path where tests to be specified in the F<Makefile.PL> will be
found.

=back

=item provides (optional)

By default the package will provide the module to be packaged and any
files included that were found if the C<recurse> option was specified.

=item resources (optional)

Keys to add to the resources section.  This section is merged into the
META_MERGE key.  See L<https://metacpan.org/pod/CPAN::Meta::Spec> for
more details.

=item extra (optional)

Name of a file that contains a list of files to be included in the
package. These files are included in the package but not installed.

=item extra-files (optional)

List of files to be included in package.

Example:

 extra-files:
   - ChangeLog
   - README
   -
     examples: ../src/examples

If you include in your extra-files specification, a 'share' directory,
then that directory will be installed as part of the
distribution.

I<This feature is only avaiable when the directory is specified in the
C<extra-files> key of the F<buildspec.yml> file. Files specified in
the C<extra> section will be copied to the root of the distribution
tarball and will not be automatically installed.>

=item exe_files (optional)

Path to look for C<.pl> and C<.sh> files to package.

=back


=head1 DEPENDENCIES

By default the script will look for dependencies in files named
F<requires> and F<test-requires>.  These are typically created by the
C<bash> script and the files are transparent to you during the
creation of the distribution.

You can specify a different name for the files with the C<-r> and
C<-t> options.

 B<You must however have a file that contains the dependency list.>

Again, if you use the C<bash> script that invokes this utility or are
calling this utility with a F<buildspec.yml> file, these files will be
I<automatically> created for you based on your options.  If you provide
your own F<requires> or F<test-requires> file, modules should be
listed as:

  module-name version

Example:

 AWS::Signature4 1.02
 ...

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=cut
